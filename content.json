[{"title":"常见架构模式MVP和MVC中M的处理方式","date":"2017-07-27T01:44:28.770Z","path":"2017/07/27/常见架构模式MVP和MVC中M的处理方式/","text":"1.利用JSON包处理这种方式需要导入JSON包，但却很方便，不需要自己做解析的过程。通常需要传入这个需要解析对象的TypeToken，不过这个M的各个字段需要跟网络接口的字段一致，不然解析的结果就为null或0。 2.利用解析接口自己做解析这种情况一般很少有人用了，毕竟自己做解析比较麻烦，M的字段可以跟网络接口的字段不一样，毕竟解析过程是自己来做，解析的时候只需要传入Json数据，然后自己完成解析。","tags":[]},{"title":"命令行中使用adb命令时提示\"error:unknown host service\"的错误","date":"2017-07-17T01:35:03.630Z","path":"2017/07/17/使用adb的错误/","text":"这个错误通常是5037端口被手机助手占用，以下是解决办法： 1. 打开命令行，输入命令：netstat -ano | findstr “5037”从以上命令的执行结果的第二列的冒号之后的就是端口号，最后一列就是进程的pid。根据该pid去任务管理器中查找对应的进程。 2. 打开任务管理器，在菜单中的查看-&gt;选择列中将PID勾选上，然后点击PID列的表头，让其递增排序便于根据pid找到进程名称。结束该进程","tags":[]},{"title":"取消SSH私钥的密码","date":"2017-07-16T12:11:53.725Z","path":"2017/07/16/取消SSH私钥文件的密码/","text":"避免使用的时候还要输入私钥的密码，干脆取消私钥文件的密码 使用openssl命令去掉私钥的密码openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa_new 备份旧私钥mv ~/.ssh/id_rsa ~/.ssh/id_rsa.backup 使用新私钥mv ~/.ssh/id_rsa_new ~/.ssh/id_rsa 设置权限chmod 600 ~/.ssh/id_rsa 这样就方便多了","tags":[]},{"title":"Activity的启动模式总结","date":"2017-07-16T11:35:15.864Z","path":"2017/07/16/Activity的启动模式总结/","text":"Activity启动时可声明启动模式，可在AndroidMainfest里声明，也可以通过Flag声明，分别如下： 在AndroidMainfest里声明Standard这是Activity的默认启动模式，采用这种启动模式每次均会创建新的实例，无可否认，这也是最常用的启动模式 SingleTop在启动时，系统会判断当前Activity所在的Task栈顶是否存在要启动的Activity，如果存在，则直接启动，否则创建新的Activity。使用情景：常用于接收到信息后显示的界面，如QQ后台接收到信息弹出Activity,如果一次来了10条信息，总不能启动10个Activity吧？所以该Activity需要声明这种启动方式。 SingleTask这种启动模式跟SingleTop很相似，不同的是，SingleTask的是系统会去检查当前整个任务栈，如果存在，则会将该栈里该Activity上面的所有Activity出栈，即该Activity移到了栈顶。如果要启动的Activity已经位于后台任务栈，则会把整个后台任务栈放到前台任务栈上面。使用情景：主Activity SingleInstance这种启动模式跟访问浏览器很相似，在很多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器里访问。声明为SingleInstance的Activity会在一个新的任务栈里，而且该栈只存在这一个Activity（这就是SingleInstance）,整个系统就只会有这个实例，举例说如果应用A的任务栈中创建了该Activity,如果B也要启动该Activity,则不需要创建，两个应用共用该Activity实例。使用情景：需要与程序分离的界面，如呼叫来电界面，在Launcher中可能使用，反正几乎不会用到 在Intent Flag里声明Intent.FLAG_ACTIVITY_NEW_TASK使用一个新的任务栈来启动该Activity,通常是在Service里启动的Activity,因为service不存在任务栈 Intent.FLAG_ACTIVITY_SINGLE_TOP类似SingleTop Intent.FLAG_ACTIVITY_CLEAR_TOP类似SingleTop Intent.FLAG_ACTIVITY_NO_HISTORY声明为该模式的Activity，每次启动新的Activity时，该Activity均会消失，即不存在任务栈中","tags":[]},{"title":"Selector中的各种状态详解","date":"2017-07-14T08:00:32.509Z","path":"2017/07/14/Selector的各种状态详解/","text":"Selector的属性可直接默认就行，我主要讲下item的各种属性： &lt;item android:drawable=&quot;@[package:]drawable/ drawable_resource&quot; android:state_pressed=[&quot;true&quot; | &quot;false&quot;] android:state_focused=[&quot;true&quot; | &quot;false&quot;] android:state_hovered=[&quot;true&quot; | &quot;false&quot;] android:state_selected=[&quot;true&quot; | &quot;false&quot;] android:state_checkable=[&quot;true&quot; | &quot;false&quot;] android:state_checked=[&quot;true&quot; | &quot;false&quot;] android:state_enabled=[&quot;true&quot; | &quot;false&quot;] android:state_activated=[&quot;true&quot; | &quot;false&quot;] android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt; 1、android:drawable=”@[package:]drawable/drawable_resource”这个是说如果系统匹配上当前这个item（也就是要使用这个item），那么就用这里设置的资源这个资源,一般都为图片。 2、android:state_pressed=[“true” | “false”]这个是说当前这个组件是否被按下，如果要设置按下的那一刻的状态，那么这里就要设置为true，例如，一个Button当手按下去后，还没有离开的状态(就是touched住的时候，还没有放开，和Clicked，点击时的那一刻)。 3、android:state_focused=[“true” | “false”] 这个是当获得焦点的时候的状态,就是当控件高亮的时候的状态，哪些情况可以造成此状态呢，比如说，轨迹球（有的手机上面有一个小球，可以用手指在上面向不同的方向滚动，滚动的时候，界面里面的焦点，就会转向滚动的方向的控件），还有就是d-pad之类的东西（比如果游戏手柄上面的上下左右键，还有键盘上面的上下左右键等）这些东西就可以控制组件上面的焦点。 4、android:state_hovered=[“true” | “false”] 这个是api等组在14以上才有的,这个是当光标移动到某一个组件之上的时候的状态，到目前为止，还没有看见过哪个手机设备带有鼠标之类的东西，可能这个专门是为平板电脑设置的或者以后可能出现带有鼠标之类的设备而准备的吧，文档中说，一般这个值设置为与focused这个值一样。 5、android:state_selected=[“true” | “false”] 这个是当一个tab被打开的状态。或者一个listView等里面一个item被选择的时候的状态,因此这个属性设置在一般的组件上面是没有用的，只有设置有作为tab或item的布局里面的项时，这个属才起作用. 6、android:state_checkable=[“true” | “false”] 这个是当一个组件在可以checked或不可以checked的时候的状态，现在较常见的，能够checkable的组件有，单选项和多选项，所以这个属性只有设置在像这类组件上面才有作用的。 7、android:state_checked=[“true” | “false”] 这个是当一个组件被checked 或者没有checked 的时候的状态，也就是说只有在可checkable上面的组件才有作用的，一般常见的就是多选按钮组与单选按钮组里面的项，这个才有作用的。 8、android:state_enabled=[“true” | “false”] 这个是当一个组件是否能处理touch或click事件的时候的状态，如果要对组件能否响应事件设置不同背景的时候，就要靠这个属性了. 9、android:state_window_focused=[“true” | “false”] 这个是是否对当前界面是否得到焦点的两种状态的设置，比如说当我们打开一个界面，那么这个界面就获得了焦点，如果我们去把“通知”拉下来，那么这个界面就失去焦点，或者弹出了一个对话框，那么这个界面也失去焦点了。","tags":[]},{"title":"Android内存泄漏场景","date":"2017-07-13T15:24:33.782Z","path":"2017/07/13/android内存泄漏场景/","text":"在开发过程中，经常发生Android的内存泄漏，如以下几种： 一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask如下：123456789101112131415161718192021222324252627282930313233343536373839public class SyncTaskDemoActivity extends Activity &#123; private int today = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 异步执行任务 new AsyncTask&lt;Object, Void, Boolean&gt;() &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Object... params) &#123; // do something in backfround // 长时间的耗时 while (true) &#123; today++; if (today &gt; 100000) break; &#125; return true; &#125; @Override protected void onPostExecute(Boolean result) &#123; super.onPostExecute(result); if (result) &#123; // success do something &#125; else &#123; // error &#125; &#125; &#125;.execute(); &#125; &#125; 修改后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SyncTaskDemoActivity extends Activity &#123; private int today = 0; private AsyncTask mAsyncTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mAsyncTask = new AsyncTask&lt;Object, Void, Boolean&gt;() &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Object... params) &#123; // do something in backfround // 长时间的耗时 while (true) &#123; if (cancel(true)) break; today++; if (today &gt; 100000) break; &#125; return true; &#125; @Override protected void onPostExecute(Boolean result) &#123; super.onPostExecute(result); if (result) &#123; // success do something &#125; else &#123; // error &#125; &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125; &#125;; // 异步执行任务 mAsyncTask.execute(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mAsyncTask.cancel(true); &#125; &#125; 解决办法：继承该类，并声明为静态私有，因为静态私有类不持有外部类的引用，对于AsyncTask可以执行cancle方法 二、静态变量持有该类的实例，销毁时，无法释放该实例以下代码均会导致内存泄漏123456789public class MainActivity extends Activity&#123; private static Context sContext;@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); sContext = this; &#125;&#125; 或123456789public class MainActivity extends Activity&#123; private static View view;@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); view = new View(this); &#125;&#125; 三、单例模式导致的内存泄漏12345678910111213141516171819202122232425262728public class TestManager&#123; private List&lt;OnDataArrivedListener&gt; listeners = new ArrayList&lt;&gt;(); private static class SingletonHolder&#123; public static final TestManager instance = new TestManager(); &#125; private TestManager()&#123; &#125; public static TestManager getInstance()&#123; return SingletonHolder.instance; &#125; public synchronized void registerListener(OnDataArrivedListener listener)&#123; if (!listeners.equals(listener)) listeners.add(listener); &#125; public synchronized void unregisterListener(OnDataArrivedListener listener)&#123; if (listeners.equals(listener)) listeners.remove(listener); &#125; public interface OnDataArrivedListener&#123; public void onDataArrived(Object data); &#125;&#125; 原因：由于疏忽，忘了写解绑，就会导致内存泄漏 四、属性动画属性动画持有该类的一个View,若该类销毁时，属性动画还在执行，将导致内存泄漏解决办法：调用属性动画的cancel","tags":[]},{"title":"建立SSH连接","date":"2017-07-12T19:18:58.757Z","path":"2017/07/13/建立SSH连接/","text":"为了方便与服务器的连接，避免每次都需输入密码，可采用SSH连接方式代替Http连接，这里简要介绍如何进行连接 1、登录到服务器（我这里用的是ubuntu)ssh -l root 123.207.244.252#root为用户名 2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）ssh-keygen -t rsa 3、在.ssh文件夹内创建authorized_keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限less id_rsa.pub &gt; authorized_keys chmod 777 authorized_keys 4、将秘钥从服务端下载下来保存到本地用户目录下的.ssh文件夹下scp -r root@123.207.244.252:~/.ssh/id_rsa ~/.ssh/id_rsa 5、之后访问服务器就不需要密码了","tags":[]}]