[{"title":"cookie和session的区别详解","date":"2017-08-11T04:42:54.059Z","path":"2017/08/11/Session和Cookies的区别详解/","text":"今天跟一个工程师讨论，才发现确实对着方面不是很懂，尴尬后赶快再回去看了一波 二者的定义：当你在浏览网站的时候，WEB 服务器会先送一小小资料放在你的计算机上，Cookie 会帮你在网站上所打的文字或是一些选择，都纪录下来。当下次你再光临同一个网站，WEB 服务器会先看看有没有它上次留下的 Cookie 资料，有的话，就会依据 Cookie里的内容来判断使用者，送出特定的网页内容给你。 Cookie 的使用很普遍，许多有提供个人化服务的网站，都是利用 Cookie来辨认使用者，以方便送出使用者量身定做的内容，像是 Web 接口的免费 email 网站，都要用到 Cookie。 具体来说cookie机制采用的是在客户端保持状态的方案，而session机制采用的是在服务器端保持状态的方案。同时我们也看到，由于采用服务器端保持状态的方案在客户端也需要保存一个标识，所以session机制可能需要借助于cookie机制来达到保存标识的目的，但实际上它还有其他选择。 cookie机制。正统的cookie分发是通过扩展HTTP协议来实现的，服务器通过在HTTP的响应头中加上一行特殊的指示以提示浏览器按照指示生成相应的cookie。然而纯粹的客户端脚本如JavaScript或者VBScript也可以生成cookie。而cookie的使用是由浏览器按照一定的原则在后台自动发送给服务器的。浏览器检查所有存储的cookie，如果某个cookie所声明的作用范围大于等于将要请求的资源所在的位置，则把该cookie附在请求资源的HTTP请求头上发送给服务器。cookie的内容主要包括：名字，值，过期时间，路径和域。路径与域一起构成cookie的作用范围。若不设置过期时间，则表示这个cookie的生命期为浏览器会话期间，关闭浏览器窗口，cookie就消失。这种生命期为浏览器会话期的cookie被称为会话cookie。会话cookie一般不存储在硬盘上而是保存在内存里，当然这种行为并不是规范规定的。若设置了过期时间，浏览器就会把cookie保存到硬盘上，关闭后再次打开浏览器，这些cookie仍然有效直到超过设定的过期时间。存储在硬盘上的cookie可以在不同的浏览器进程间共享，比如两个IE窗口。而对于保存在内存里的cookie，不同的浏览器有不同的处理方式 session机制。session机制是一种服务器端的机制，服务器使用一种类似于散列表的结构（也可能就是使用散列表）来保存信息。当程序需要为某个客户端的请求创建一个session时，服务器首先检查这个客户端的请求里是否已包含了一个session标识（称为session id），如果已包含则说明以前已经为此客户端创建过session，服务器就按照session id把这个session检索出来使用（检索不到，会新建一个），如果客户端请求不包含session id，则为此服务器创建一个session并且生成一个与此session相关联的session id，session id的值应该是一个既不会重复，又不容易被找到规律以仿造的字符串，这个session id将被在本次响应中返回给客户端保存。保存这个session id的方式可以采用cookie，这样在交互过程中浏览器可以自动的按照规则把这个标识发送给服务器。一般这个cookie的名字都是类似于SEEESIONID。但cookie可以被人为的禁止，则必须有其他机制以便在cookie被禁止时仍然能够把session id传递回服务器。 经常被使用的一种技术叫做URL重写，就是把session id直接附加在URL路径的后面。还有一种技术叫做表单隐藏字段。实际上这种技术可以简单的用对action应用URL重写来代替。 cookie 和session 的区别：1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 不同机制请求时可以有两种解决方案实现单点登录并且多端登录互不影响1、 采用token+device（一个字段，表明不同终端）2、 采用session机制","tags":[]},{"title":"排序总结","date":"2017-07-30T00:56:52.985Z","path":"2017/07/30/排序总结/","text":"这么多的排序算法着实让我头疼，没办法，这又是笔试面试必考题，所以我只能硬着头皮做了以下的总结，以便今后的复习： 1、插入排序“有序插入”，也就是将元素逐一插到有序序列中，保持序列有序，从而使有序序列的长度不断增加 1.1、直接插入排序原理： 在插入a[i]前，数组a的前半段a[0]~a[i-1]是有序段，后半段是无序段，插入前需为a[i]找到有序位置j，将a[i]插到j的位置上 源码： void Sinsert_sort(int a[],int n){ int x; for(int i =1;i&lt;n;i++){ x = a[i]; for(int j=i-1;j&gt;=0&amp;&amp;x&lt;a[j];j--) a[j+1]=a[j]; a[j+1]=x; } } 性能分析：稳定空间复杂度：O(1)时间复杂度：O（n2) 1.2、折半插入排序原理：用二分查找方法为a[i]查找有序位置时，不像直接插入那样，边比较边移动元素，而是在查找到有序位置后将那些大于a[i]的元素一起右移 源码： void Binsert_sort(int a[],int n){ int left,right,mid,x; for(int i=1;i&lt;n;i++){ x = a[i]; left=0,right=i-1; while(left&lt;=right){ mid=(left+right)/2; if(x&lt;a[mid]) right=mid-1; else left=mid+1; } for(int j=i-1;j&gt;=left;j--) a[j+1]=a[j]; a[left]=x; } } 性能分析：稳定空间复杂度：O(1)时间复杂度：O(n2) 1.3、希尔排序原理：又称“缩小增量”排序，选用一个由多个增量组成的由大到小排列的增量序列，分别用每个增量对数组进行插入排序，任何增量序列的最后一个增量必须为1 源码： void Shell_sort(int a[],int d[],int n,int t){ int j,k,x; for(int h=0;h&lt;t;h++){ k=d[h]; for(int i=k;i&lt;n;i++){ for(x=a[i],j=i-k;j&gt;=0&amp;&amp;x&lt;a[j];j=j-k) a[j+k]=a[j]; a[j+k]=x; } } } 性能分析：不稳定根据增量序列的不一致，时间复杂度也不一致 2、交换排序如果 “i &lt; j” 而 “a[i] &gt; a[j]”,即大数排在小数的前面，则称a[i]和a[j]构成”逆序”。排序的过程中若发现逆序，就交换他们的位置。 2.1、冒泡排序原理：反复扫描数组a，比较两个相邻元素a[i]与a[i+1]的大小，若a[i]&gt;a[i+1]，就交换 源码： void buddle_sort(int a[],int n){ int x; for(int j=0;j&lt;n-1;j++){ for(int i=n-2;i&gt;=j;i--){ if(a[i]&gt;a[j+1]) x=a[i],a[i]=a[i+1],a[i+1]=x; } } } 性能分析：稳定空间复杂度：O(1)时间复杂度：O(n2) 2.2、快速排序原理：划分。 源码： void qksort(int a[],int i,int j){ int k; if(i&lt;j){ partition(a,i,j,k); qksort(a,i,k-1); qksort(a,k+1,j); } } void partition(int a[],int s,int t,int &amp;k){ int i,j,x; x=a[s]; i=s;j=t; do{ while((a[i]&gt;=x)&amp;&amp;(i&lt;j)) j--; if(i&lt;j) a[i++]=a[j]; while((a[i]&lt;x)&amp;&amp;(i&lt;j)) i++; if(i&lt;j) a[j--]=a[i]; }while(i&lt;j); a[i]=x; k=i; } 性能分析：不稳定空间复杂度：O(logn)时间复杂度：O(nlogn) 3、选择排序从n个元素中选出一个最小的元素，把它调到序列最前面，再从剩下的n-1个元素中选出最小元素,反复如此，可完成排序 3.1、直接选择排序源码： void Select_sort(int a[],int n){ for (int i = 0; i &lt; n; i++) { int min = i; for (int j = i + 1; j &lt; n; j++) { if (a[min] &gt; a[j]) min = j; } if (i != min) { int tmp = a[min]; a[min] = a[i]; a[i] = tmp; } } } 性能分析：不稳定空间复杂度：O（1）时间复杂度：O(n2) 3.2、堆排序原理：堆化（满足父大于子）、将最大元素换到尾部 源码： void heap_sort(int a[],int n){ int i,x; for(i=n/2;i&gt;=1;i--) heapify(a,i,n); for(i=n;i&gt;1;i--){ x=a[1]; a[1]=a[i]; a[i]=x; heapify(a,1,i-1); } } void heapify(int a[],int i,int j){ int k,x; k=2*i; x=a[i]; while(k&lt;=j){ if(k&lt;j) if(a[k]&lt;a[k+1]) k=k+1; if(x&gt;=a[k]) break; else a[i]=a[k],i=k,k=2*i; } a[i]=x; } 性能分析：不稳定空间复杂度：O(1)时间复杂度：O（nlogn） 4、归并排序反复将两个长度较短的有序段合并成一个有序段，直到数组中只含有一个有序段 源码： void merge_sort(int a[],int i,int j){ int k; if(i&lt;j){ k=(i+j)/2; merge_sort(a,i,k); merge_sort(a,k+1,j); merge(a,i,k,k+1,j); } } void merge(int a[],int p,int q,int s,int t){ int i,j,k,b[n];//n是已经定义的常量 i=p,j=s,k=p-1; while((i&lt;=q)&amp;&amp;(j&lt;=t)) if(a[i]&lt;=a[j]) b[++k]=a[i++]; else b[++k]=a[j++]; while(i&lt;=q) b[++k]=a[i++]; while(j&lt;=t) b[++k]=a[j++]; for(i=p;i&lt;=t;i++) a[i]=b[i]; } 性能分析：稳定空间复杂度：O(n)时间复杂度：O（nlogn）","tags":[]},{"title":"我的MVP实现","date":"2017-07-27T01:57:38.805Z","path":"2017/07/27/我的MVP实现/","text":"其实MVP的实现方式理解起来也比较简单，只需要把获取数据的过程，比如网络、本地数据获取交给P即Presenter去操作，然后把视图逻辑更新过程交给View去实现，至于Model，只是在Presenter完成数据的获取过程中完成实例化。 步骤一：接口IContract作为接口IPresenter和接口IView的合并public interface IHomeContract { interface IView extends IFragmentBaseView&lt;IPresenter&gt; { //更新列表数据 void updateHomeList(List list); //上拉更新数据 void updateMoreList(List list); } interface IPresenter extends IBasePresenter { void loadHomeData(int pageItems,OnResponseListener listener); void loadMoreData(int currentPage,int pageItems,OnResponseListener listener); List getAdverts(); List getNavigation(); List getFoods(); PrizeItem getPrize(); } } 步骤二：定义IPresenter实现类IHomeContract.IView homeView; DataFactory.RemoteDataFactoryInter factory; private List&lt;Advert&gt; adverts; private List&lt;NavigationItem&gt; navigationItems; private PrizeItem item; private List&lt;FoodItem&gt; foodItems; public HomePresenter(IHomeContract.IView homeView){ this.homeView = homeView; this.factory = DataManager.getRemoteDataFactory(); } @Override public void loadHomeData(final int pageItems, final OnResponseListener listener) { final List data = new ArrayList(); factory.getAdvert(new OnResponseListener&lt;AdvertResponse&gt;() { @Override public void onSuccess(AdvertResponse o) { adverts = o.getData(); data.add(adverts); factory.getNavigation(new OnResponseListener&lt;NavigationResponse&gt;() { @Override public void onSuccess(NavigationResponse o) { navigationItems = o.getData(); data.add(navigationItems); factory.getPrize(new OnResponseListener&lt;PrizeResponse&gt;() { @Override public void onSuccess(PrizeResponse o) { item = o.getData(); data.add(item); factory.getFood(1, pageItems, &quot;all&quot;, new OnResponseListener&lt;FoodResponse&gt;() { @Override public void onSuccess(FoodResponse o) { foodItems = o.getData(); for (FoodItem foodItem:foodItems){ data.add(foodItem); } listener.onSuccess(data); } @Override public void onFail(int status, String errorMsg) { listener.onFail(status,errorMsg); } }); } @Override public void onFail(int status, String errorMsg) { listener.onFail(status,errorMsg); } }); } @Override public void onFail(int status, String errorMsg) { listener.onFail(status,errorMsg); } }); } @Override public void onFail(int status, String errorMsg) { listener.onFail(status,errorMsg); } }); } @Override public void loadMoreData(int currentPage, int pageItems, final OnResponseListener listener) { factory.getFood(currentPage, pageItems, &quot;all&quot;, new OnResponseListener&lt;FoodResponse&gt;() { @Override public void onSuccess(FoodResponse o) { List&lt;FoodItem&gt; items = o.getData(); listener.onSuccess(items); } @Override public void onFail(int status, String errorMsg) { listener.onFail(status,errorMsg); } }); } @Override public List getAdverts() { return adverts; } @Override public List getNavigation() { return navigationItems; } @Override public List getFoods() { return foodItems; } @Override public PrizeItem getPrize() { return item; } } 步骤三：让Fragment或Activity实现IView,这里就不列代码了步骤四：如开始所说，将视图更新和数据获取分离","tags":[]},{"title":"常见架构模式MVP和MVC中M的处理方式","date":"2017-07-27T01:44:28.770Z","path":"2017/07/27/常见架构模式MVP和MVC中M的处理方式/","text":"对于M，在解析网络JSON数据时我觉得可以有两种方式，一种是交给JSON框架去解析，另一种则是自己定义一个解析接口，自己做解析，也就是说把拿取数据的过程交给M自己去做。 1.利用JSON包处理这种方式需要导入JSON包，但却很方便，不需要自己做解析的过程。通常需要传入这个需要解析对象的TypeToken，不过这个M的各个字段需要跟网络接口的字段一致，不然解析的结果就为null或0。 2.利用解析接口自己做解析这种情况一般很少有人用了，毕竟自己做解析比较麻烦，M的字段可以跟网络接口的字段不一样，毕竟解析过程是自己来做，解析的时候只需要传入Json数据，然后自己完成解析。","tags":[]},{"title":"命令行中使用adb命令时提示\"error:unknown host service\"的错误","date":"2017-07-17T01:35:03.630Z","path":"2017/07/17/使用adb的错误/","text":"这个错误通常是5037端口被手机助手占用，以下是解决办法： 1. 打开命令行，输入命令：netstat -ano | findstr “5037”从以上命令的执行结果的第二列的冒号之后的就是端口号，最后一列就是进程的pid。根据该pid去任务管理器中查找对应的进程。 2. 打开任务管理器，在菜单中的查看-&gt;选择列中将PID勾选上，然后点击PID列的表头，让其递增排序便于根据pid找到进程名称。结束该进程","tags":[]},{"title":"取消SSH私钥的密码","date":"2017-07-16T12:11:53.725Z","path":"2017/07/16/取消SSH私钥文件的密码/","text":"避免使用的时候还要输入私钥的密码，干脆取消私钥文件的密码 使用openssl命令去掉私钥的密码openssl rsa -in ~/.ssh/id_rsa -out ~/.ssh/id_rsa_new 备份旧私钥mv ~/.ssh/id_rsa ~/.ssh/id_rsa.backup 使用新私钥mv ~/.ssh/id_rsa_new ~/.ssh/id_rsa 设置权限chmod 600 ~/.ssh/id_rsa 这样就方便多了","tags":[]},{"title":"Activity的启动模式总结","date":"2017-07-16T11:35:15.864Z","path":"2017/07/16/Activity的启动模式总结/","text":"Activity启动时可声明启动模式，可在AndroidMainfest里声明，也可以通过Flag声明，分别如下： 在AndroidMainfest里声明Standard这是Activity的默认启动模式，采用这种启动模式每次均会创建新的实例，无可否认，这也是最常用的启动模式 SingleTop在启动时，系统会判断当前Activity所在的Task栈顶是否存在要启动的Activity，如果存在，则直接启动，否则创建新的Activity。使用情景：常用于接收到信息后显示的界面，如QQ后台接收到信息弹出Activity,如果一次来了10条信息，总不能启动10个Activity吧？所以该Activity需要声明这种启动方式。 SingleTask这种启动模式跟SingleTop很相似，不同的是，SingleTask的是系统会去检查当前整个任务栈，如果存在，则会将该栈里该Activity上面的所有Activity出栈，即该Activity移到了栈顶。如果要启动的Activity已经位于后台任务栈，则会把整个后台任务栈放到前台任务栈上面。使用情景：主Activity SingleInstance这种启动模式跟访问浏览器很相似，在很多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器里访问。声明为SingleInstance的Activity会在一个新的任务栈里，而且该栈只存在这一个Activity（这就是SingleInstance）,整个系统就只会有这个实例，举例说如果应用A的任务栈中创建了该Activity,如果B也要启动该Activity,则不需要创建，两个应用共用该Activity实例。使用情景：需要与程序分离的界面，如呼叫来电界面，在Launcher中可能使用，反正几乎不会用到 在Intent Flag里声明Intent.FLAG_ACTIVITY_NEW_TASK使用一个新的任务栈来启动该Activity,通常是在Service里启动的Activity,因为service不存在任务栈 Intent.FLAG_ACTIVITY_SINGLE_TOP类似SingleTop Intent.FLAG_ACTIVITY_CLEAR_TOP类似SingleTask Intent.FLAG_ACTIVITY_NO_HISTORY声明为该模式的Activity，每次启动新的Activity时，该Activity均会消失，即不存在任务栈中","tags":[]},{"title":"Selector中的各种状态详解","date":"2017-07-14T08:00:32.509Z","path":"2017/07/14/Selector的各种状态详解/","text":"Selector的属性可直接默认就行，我主要讲下item的各种属性： &lt;item android:drawable=&quot;@[package:]drawable/ drawable_resource&quot; android:state_pressed=[&quot;true&quot; | &quot;false&quot;] android:state_focused=[&quot;true&quot; | &quot;false&quot;] android:state_hovered=[&quot;true&quot; | &quot;false&quot;] android:state_selected=[&quot;true&quot; | &quot;false&quot;] android:state_checkable=[&quot;true&quot; | &quot;false&quot;] android:state_checked=[&quot;true&quot; | &quot;false&quot;] android:state_enabled=[&quot;true&quot; | &quot;false&quot;] android:state_activated=[&quot;true&quot; | &quot;false&quot;] android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt; 1、android:drawable=”@[package:]drawable/drawable_resource”这个是说如果系统匹配上当前这个item（也就是要使用这个item），那么就用这里设置的资源这个资源,一般都为图片。 2、android:state_pressed=[“true” | “false”]这个是说当前这个组件是否被按下，如果要设置按下的那一刻的状态，那么这里就要设置为true，例如，一个Button当手按下去后，还没有离开的状态(就是touched住的时候，还没有放开，和Clicked，点击时的那一刻)。 3、android:state_focused=[“true” | “false”] 这个是当获得焦点的时候的状态,就是当控件高亮的时候的状态，哪些情况可以造成此状态呢，比如说，轨迹球（有的手机上面有一个小球，可以用手指在上面向不同的方向滚动，滚动的时候，界面里面的焦点，就会转向滚动的方向的控件），还有就是d-pad之类的东西（比如果游戏手柄上面的上下左右键，还有键盘上面的上下左右键等）这些东西就可以控制组件上面的焦点。 4、android:state_hovered=[“true” | “false”] 这个是api等组在14以上才有的,这个是当光标移动到某一个组件之上的时候的状态，到目前为止，还没有看见过哪个手机设备带有鼠标之类的东西，可能这个专门是为平板电脑设置的或者以后可能出现带有鼠标之类的设备而准备的吧，文档中说，一般这个值设置为与focused这个值一样。 5、android:state_selected=[“true” | “false”] 这个是当一个tab被打开的状态。或者一个listView等里面一个item被选择的时候的状态,因此这个属性设置在一般的组件上面是没有用的，只有设置有作为tab或item的布局里面的项时，这个属才起作用. 6、android:state_checkable=[“true” | “false”] 这个是当一个组件在可以checked或不可以checked的时候的状态，现在较常见的，能够checkable的组件有，单选项和多选项，所以这个属性只有设置在像这类组件上面才有作用的。 7、android:state_checked=[“true” | “false”] 这个是当一个组件被checked 或者没有checked 的时候的状态，也就是说只有在可checkable上面的组件才有作用的，一般常见的就是多选按钮组与单选按钮组里面的项，这个才有作用的。 8、android:state_enabled=[“true” | “false”] 这个是当一个组件是否能处理touch或click事件的时候的状态，如果要对组件能否响应事件设置不同背景的时候，就要靠这个属性了. 9、android:state_window_focused=[“true” | “false”] 这个是是否对当前界面是否得到焦点的两种状态的设置，比如说当我们打开一个界面，那么这个界面就获得了焦点，如果我们去把“通知”拉下来，那么这个界面就失去焦点，或者弹出了一个对话框，那么这个界面也失去焦点了。","tags":[]},{"title":"Android内存泄漏场景","date":"2017-07-13T15:24:33.782Z","path":"2017/07/13/android内存泄漏场景/","text":"在开发过程中，经常发生Android的内存泄漏，如以下几种： 一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask如下：123456789101112131415161718192021222324252627282930313233343536373839public class SyncTaskDemoActivity extends Activity &#123; private int today = 0; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 异步执行任务 new AsyncTask&lt;Object, Void, Boolean&gt;() &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Object... params) &#123; // do something in backfround // 长时间的耗时 while (true) &#123; today++; if (today &gt; 100000) break; &#125; return true; &#125; @Override protected void onPostExecute(Boolean result) &#123; super.onPostExecute(result); if (result) &#123; // success do something &#125; else &#123; // error &#125; &#125; &#125;.execute(); &#125; &#125; 修改后：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public class SyncTaskDemoActivity extends Activity &#123; private int today = 0; private AsyncTask mAsyncTask; @Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mAsyncTask = new AsyncTask&lt;Object, Void, Boolean&gt;() &#123; @Override protected void onPreExecute() &#123; super.onPreExecute(); &#125; @Override protected Boolean doInBackground(Object... params) &#123; // do something in backfround // 长时间的耗时 while (true) &#123; if (cancel(true)) break; today++; if (today &gt; 100000) break; &#125; return true; &#125; @Override protected void onPostExecute(Boolean result) &#123; super.onPostExecute(result); if (result) &#123; // success do something &#125; else &#123; // error &#125; &#125; @Override protected void onCancelled() &#123; super.onCancelled(); &#125; &#125;; // 异步执行任务 mAsyncTask.execute(); &#125; @Override protected void onDestroy() &#123; super.onDestroy(); mAsyncTask.cancel(true); &#125; &#125; 解决办法：继承该类，并声明为静态私有，因为静态私有类不持有外部类的引用，对于AsyncTask可以执行cancle方法 二、静态变量持有该类的实例，销毁时，无法释放该实例以下代码均会导致内存泄漏123456789public class MainActivity extends Activity&#123; private static Context sContext;@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); sContext = this; &#125;&#125; 或123456789public class MainActivity extends Activity&#123; private static View view;@Override protected void onCreate(@Nullable Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); view = new View(this); &#125;&#125; 三、单例模式导致的内存泄漏12345678910111213141516171819202122232425262728public class TestManager&#123; private List&lt;OnDataArrivedListener&gt; listeners = new ArrayList&lt;&gt;(); private static class SingletonHolder&#123; public static final TestManager instance = new TestManager(); &#125; private TestManager()&#123; &#125; public static TestManager getInstance()&#123; return SingletonHolder.instance; &#125; public synchronized void registerListener(OnDataArrivedListener listener)&#123; if (!listeners.equals(listener)) listeners.add(listener); &#125; public synchronized void unregisterListener(OnDataArrivedListener listener)&#123; if (listeners.equals(listener)) listeners.remove(listener); &#125; public interface OnDataArrivedListener&#123; public void onDataArrived(Object data); &#125;&#125; 原因：由于疏忽，忘了写解绑，就会导致内存泄漏 四、属性动画属性动画持有该类的一个View,若该类销毁时，属性动画还在执行，将导致内存泄漏解决办法：调用属性动画的cancel","tags":[]},{"title":"建立SSH连接","date":"2017-07-12T19:18:58.757Z","path":"2017/07/13/建立SSH连接/","text":"为了方便与服务器的连接，避免每次都需输入密码，可采用SSH连接方式代替Http连接，这里简要介绍如何进行连接 1、登录到服务器（我这里用的是ubuntu)ssh -l root 123.207.244.252#root为用户名 2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）ssh-keygen -t rsa 3、在.ssh文件夹内创建authorized_keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限less id_rsa.pub &gt; authorized_keys chmod 777 authorized_keys 4、将秘钥从服务端下载下来保存到本地用户目录下的.ssh文件夹下scp -r root@123.207.244.252:~/.ssh/id_rsa ~/.ssh/id_rsa 5、之后访问服务器就不需要密码了","tags":[]}]