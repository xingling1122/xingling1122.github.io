<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>星林的窗</title>
  <subtitle>一天进步一点</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2017-07-16T11:59:47.214Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>xingling</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Activity的启动模式总结1</title>
    <link href="http://yoursite.com/2017/07/16/Activity%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2017/07/16/Activity的启动模式总结/</id>
    <published>2017-07-16T11:35:15.864Z</published>
    <updated>2017-07-16T11:59:47.214Z</updated>
    
    <content type="html"><![CDATA[<p>Activity启动时可声明启动模式，可在AndroidMainfest里声明，也可以通过Flag声明，分别如下：  </p>
<h2 id="在AndroidMainfest里声明"><a href="#在AndroidMainfest里声明" class="headerlink" title="在AndroidMainfest里声明"></a>在AndroidMainfest里声明</h2><h3 id="Standard"><a href="#Standard" class="headerlink" title="Standard"></a>Standard</h3><p>这是Activity的默认启动模式，采用这种启动模式每次均会创建新的实例，无可否认，这也是最常用的启动模式  </p>
<h3 id="SingleTop"><a href="#SingleTop" class="headerlink" title="SingleTop"></a>SingleTop</h3><p>在启动时，系统会判断当前Activity所在的Task栈顶是否存在要启动的Activity，如果存在，则直接启动，否则创建新的Activity。使用情景：常用于接收到信息后显示的界面，如QQ后台接收到信息弹出Activity,如果一次来了10条信息，总不能启动10个Activity吧？所以该Activity需要声明这种启动方式。  </p>
<h3 id="SingleTask"><a href="#SingleTask" class="headerlink" title="SingleTask"></a>SingleTask</h3><p>这种启动模式跟SingleTop很相似，不同的是，SingleTask的是系统会去检查当前整个任务栈，如果存在，则会将该栈里该Activity上面的所有Activity出栈，即该Activity移到了栈顶。如果要启动的Activity已经位于后台任务栈，则会把整个后台任务栈放到前台任务栈上面。使用情景：<br>主Activity  </p>
<h3 id="SingleInstance"><a href="#SingleInstance" class="headerlink" title="SingleInstance"></a>SingleInstance</h3><p>这种启动模式跟访问浏览器很相似，在很多个程序中访问浏览器时，如果当前浏览器没有打开，则打开浏览器，否则会在当前打开的浏览器里访问。<br>声明为SingleInstance的Activity会在一个新的任务栈里，而且该栈只存在这一个Activity（这就是SingleInstance）,整个系统就只会有这个实例，举例说如果应用A的任务栈中创建了该Activity,如果B也要启动该Activity,则不需要创建，两个应用共用该Activity实例。使用情景：需要与程序分离的界面，如呼叫来电界面，在Launcher中可能使用，反正几乎不会用到  </p>
<h2 id="在Intent-Flag里声明"><a href="#在Intent-Flag里声明" class="headerlink" title="在Intent Flag里声明"></a>在Intent Flag里声明</h2><h3 id="Intent-FLAG-ACTIVITY-NEW-TASK"><a href="#Intent-FLAG-ACTIVITY-NEW-TASK" class="headerlink" title="Intent.FLAG_ACTIVITY_NEW_TASK"></a>Intent.FLAG_ACTIVITY_NEW_TASK</h3><p>使用一个新的任务栈来启动该Activity,通常是在Service里启动的Activity,因为service不存在任务栈  </p>
<h3 id="Intent-FLAG-ACTIVITY-SINGLE-TOP"><a href="#Intent-FLAG-ACTIVITY-SINGLE-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_SINGLE_TOP"></a>Intent.FLAG_ACTIVITY_SINGLE_TOP</h3><p>类似SingleTop  </p>
<h3 id="Intent-FLAG-ACTIVITY-CLEAR-TOP"><a href="#Intent-FLAG-ACTIVITY-CLEAR-TOP" class="headerlink" title="Intent.FLAG_ACTIVITY_CLEAR_TOP"></a>Intent.FLAG_ACTIVITY_CLEAR_TOP</h3><p>类似SingleTop</p>
<h3 id="Intent-FLAG-ACTIVITY-NO-HISTORY"><a href="#Intent-FLAG-ACTIVITY-NO-HISTORY" class="headerlink" title="Intent.FLAG_ACTIVITY_NO_HISTORY"></a>Intent.FLAG_ACTIVITY_NO_HISTORY</h3><p>声明为该模式的Activity，每次启动新的Activity时，该Activity均会消失，即不存在任务栈中</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Activity启动时可声明启动模式，可在AndroidMainfest里声明，也可以通过Flag声明，分别如下：  &lt;/p&gt;
&lt;h2 id=&quot;在AndroidMainfest里声明&quot;&gt;&lt;a href=&quot;#在AndroidMainfest里声明&quot; class=&quot;header
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Selector中的各种状态详解</title>
    <link href="http://yoursite.com/2017/07/14/Selector%E7%9A%84%E5%90%84%E7%A7%8D%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2017/07/14/Selector的各种状态详解/</id>
    <published>2017-07-14T08:00:32.509Z</published>
    <updated>2017-07-14T08:12:05.407Z</updated>
    
    <content type="html"><![CDATA[<p>Selector的属性可直接默认就行，我主要讲下item的各种属性：</p>
<pre><code>&lt;item 

    android:drawable=&quot;@[package:]drawable/     drawable_resource&quot;  

     android:state_pressed=[&quot;true&quot; | &quot;false&quot;]

    android:state_focused=[&quot;true&quot; | &quot;false&quot;]

     android:state_hovered=[&quot;true&quot; | &quot;false&quot;]

     android:state_selected=[&quot;true&quot; | &quot;false&quot;]

     android:state_checkable=[&quot;true&quot; | &quot;false&quot;]

     android:state_checked=[&quot;true&quot; | &quot;false&quot;]

     android:state_enabled=[&quot;true&quot; | &quot;false&quot;]

     android:state_activated=[&quot;true&quot; | &quot;false&quot;]

     android:state_window_focused=[&quot;true&quot; | &quot;false&quot;] /&gt;
</code></pre><p>1、android:drawable=”@[package:]drawable/drawable_resource”<br>这个是说如果系统匹配上当前这个item（也就是要使用这个item），那么就用这里设置的资源这个资源,一般都为图片。</p>
<p>2、android:state_pressed=[“true” | “false”]<br>这个是说当前这个组件是否被按下，如果要设置按下的那一刻的状态，那么这里就要设置为true，例如，一个Button当手按下去后，还没有离开的状态(就是touched住的时候，还没有放开，和Clicked，点击时的那一刻)。</p>
<p>3、android:state_focused=[“true” | “false”]</p>
<p>这个是当获得焦点的时候的状态,就是当控件高亮的时候的状态，哪些情况可以造成此状态呢，比如说，轨迹球（有的手机上面有一个小球，可以用手指在上面向不同的方向滚动，滚动的时候，界面里面的焦点，就会转向滚动的方向的控件），还有就是d-pad之类的东西（比如果游戏手柄上面的上下左右键，还有键盘上面的上下左右键等）这些东西就可以控制组件上面的焦点。</p>
<p>4、android:state_hovered=[“true” | “false”]</p>
<p>这个是api等组在14以上才有的,这个是当光标移动到某一个组件之上的时候的状态，到目前为止，还没有看见过哪个手机设备带有鼠标之类的东西，可能这个专门是为平板电脑设置的或者以后可能出现带有鼠标之类的设备而准备的吧，文档中说，一般这个值设置为与focused这个值一样。</p>
<p>5、android:state_selected=[“true” | “false”]</p>
<p>这个是当一个tab被打开的状态。或者一个listView等里面一个item被选择的时候的状态,因此这个属性设置在一般的组件上面是没有用的，只有设置有作为tab或item的布局里面的项时，这个属才起作用.</p>
<p>6、android:state_checkable=[“true” | “false”]</p>
<p>这个是当一个组件在可以checked或不可以checked的时候的状态，现在较常见的，能够checkable的组件有，单选项和多选项，所以这个属性只有设置在像这类组件上面才有作用的。</p>
<p>7、android:state_checked=[“true” | “false”]</p>
<p>这个是当一个组件被checked 或者没有checked 的时候的状态，也就是说只有在可checkable上面的组件才有作用的，一般常见的就是多选按钮组与单选按钮组里面的项，这个才有作用的。</p>
<p>8、android:state_enabled=[“true” | “false”]</p>
<p>这个是当一个组件是否能处理touch或click事件的时候的状态，如果要对组件能否响应事件设置不同背景的时候，就要靠这个属性了.</p>
<p>9、android:state_window_focused=[“true” | “false”]</p>
<p>这个是是否对当前界面是否得到焦点的两种状态的设置，比如说当我们打开一个界面，那么这个界面就获得了焦点，如果我们去把“通知”拉下来，那么这个界面就失去焦点，或者弹出了一个对话框，那么这个界面也失去焦点了。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Selector的属性可直接默认就行，我主要讲下item的各种属性：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;item 

    android:drawable=&amp;quot;@[package:]drawable/     drawable_resource&amp;quot; 
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android内存泄漏场景</title>
    <link href="http://yoursite.com/2017/07/13/android%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E5%9C%BA%E6%99%AF/"/>
    <id>http://yoursite.com/2017/07/13/android内存泄漏场景/</id>
    <published>2017-07-13T15:24:33.782Z</published>
    <updated>2017-07-16T11:38:06.614Z</updated>
    
    <content type="html"><![CDATA[<p>在开发过程中，经常发生Android的内存泄漏，如以下几种：  </p>
<h3 id="一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask"><a href="#一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask" class="headerlink" title="一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask"></a>一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask</h3><p>如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></td><td class="code"><pre><div class="line">public class SyncTaskDemoActivity extends Activity &#123;  </div><div class="line">    private int today = 0;  </div><div class="line"></div><div class="line">    @Override  </div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </div><div class="line">        super.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.activity_main);  </div><div class="line"></div><div class="line">        // 异步执行任务  </div><div class="line">        new AsyncTask&lt;Object, Void, Boolean&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            protected void onPreExecute() &#123;  </div><div class="line">                super.onPreExecute();  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            protected Boolean doInBackground(Object... params) &#123;  </div><div class="line">                // do something in backfround  </div><div class="line">                // 长时间的耗时  </div><div class="line">                while (true) &#123;  </div><div class="line">                    today++;  </div><div class="line">                    if (today &gt; 100000)  </div><div class="line">                        break;  </div><div class="line">                &#125;  </div><div class="line">                return true;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            protected void onPostExecute(Boolean result) &#123;  </div><div class="line">                super.onPostExecute(result);  </div><div class="line">                if (result) &#123;  </div><div class="line">                    // success do something  </div><div class="line">                &#125; else &#123;  </div><div class="line">                    // error  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">        &#125;.execute();  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>修改后：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">public class SyncTaskDemoActivity extends Activity &#123;  </div><div class="line">    private int today = 0;  </div><div class="line">    private AsyncTask mAsyncTask;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onCreate(Bundle savedInstanceState) &#123;  </div><div class="line">        super.onCreate(savedInstanceState);  </div><div class="line">        setContentView(R.layout.activity_main);  </div><div class="line">  </div><div class="line">        mAsyncTask = new AsyncTask&lt;Object, Void, Boolean&gt;() &#123;  </div><div class="line">            @Override  </div><div class="line">            protected void onPreExecute() &#123;  </div><div class="line">                super.onPreExecute();  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            protected Boolean doInBackground(Object... params) &#123;  </div><div class="line">                // do something in backfround  </div><div class="line">                // 长时间的耗时  </div><div class="line">                while (true) &#123;  </div><div class="line">                    if (cancel(true))  </div><div class="line">                        break;  </div><div class="line">                    today++;  </div><div class="line">                    if (today &gt; 100000)  </div><div class="line">                        break;  </div><div class="line">                &#125;  </div><div class="line">                return true;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            protected void onPostExecute(Boolean result) &#123;  </div><div class="line">                super.onPostExecute(result);  </div><div class="line">                if (result) &#123;  </div><div class="line">                    // success do something  </div><div class="line">                &#125; else &#123;  </div><div class="line">                    // error  </div><div class="line">                &#125;  </div><div class="line">            &#125;  </div><div class="line">  </div><div class="line">            @Override  </div><div class="line">            protected void onCancelled() &#123;  </div><div class="line">                super.onCancelled();  </div><div class="line">            &#125;  </div><div class="line">        &#125;;  </div><div class="line">        // 异步执行任务  </div><div class="line">        mAsyncTask.execute();  </div><div class="line">    &#125;  </div><div class="line">  </div><div class="line">    @Override  </div><div class="line">    protected void onDestroy() &#123;  </div><div class="line">        super.onDestroy();  </div><div class="line">        mAsyncTask.cancel(true);  </div><div class="line">    &#125;  </div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>解决办法：继承该类，并声明为静态私有，因为静态私有类不持有外部类的引用，对于AsyncTask可以执行cancle方法</p>
<h3 id="二、静态变量持有该类的实例，销毁时，无法释放该实例"><a href="#二、静态变量持有该类的实例，销毁时，无法释放该实例" class="headerlink" title="二、静态变量持有该类的实例，销毁时，无法释放该实例"></a>二、静态变量持有该类的实例，销毁时，无法释放该实例</h3><p>以下代码均会导致内存泄漏<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">  private static Context sContext;</div><div class="line"></div><div class="line">@Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        sContext = this;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>或<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">public class MainActivity extends Activity&#123;</div><div class="line">  private static View view;</div><div class="line"></div><div class="line">@Override</div><div class="line">    protected void onCreate(@Nullable Bundle savedInstanceState) &#123;</div><div class="line">        super.onCreate(savedInstanceState);</div><div class="line">        view = new View(this);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h3 id="三、单例模式导致的内存泄漏"><a href="#三、单例模式导致的内存泄漏" class="headerlink" title="三、单例模式导致的内存泄漏"></a>三、单例模式导致的内存泄漏</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class TestManager&#123;</div><div class="line">    private List&lt;OnDataArrivedListener&gt; listeners = new ArrayList&lt;&gt;();</div><div class="line">    private static class SingletonHolder&#123;</div><div class="line">        public static final TestManager instance = new TestManager();</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    private TestManager()&#123;</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public static TestManager getInstance()&#123;</div><div class="line">        return SingletonHolder.instance;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized void registerListener(OnDataArrivedListener listener)&#123;</div><div class="line">        if (!listeners.equals(listener))</div><div class="line">            listeners.add(listener);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public synchronized  void unregisterListener(OnDataArrivedListener listener)&#123;</div><div class="line">        if (listeners.equals(listener))</div><div class="line">            listeners.remove(listener);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    public interface OnDataArrivedListener&#123;</div><div class="line">        public void onDataArrived(Object data);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>原因：由于疏忽，忘了写解绑，就会导致内存泄漏</p>
<h3 id="四、属性动画"><a href="#四、属性动画" class="headerlink" title="四、属性动画"></a>四、属性动画</h3><p>属性动画持有该类的一个View,若该类销毁时，属性动画还在执行，将导致内存泄漏<br>解决办法：调用属性动画的cancel</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在开发过程中，经常发生Android的内存泄漏，如以下几种：  &lt;/p&gt;
&lt;h3 id=&quot;一、匿名内部类持有外部类的引用，如常用的Thread、Handler和AsyncTask&quot;&gt;&lt;a href=&quot;#一、匿名内部类持有外部类的引用，如常用的Thread、Handler和A
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>建立SSH连接</title>
    <link href="http://yoursite.com/2017/07/13/%E5%BB%BA%E7%AB%8BSSH%E8%BF%9E%E6%8E%A5/"/>
    <id>http://yoursite.com/2017/07/13/建立SSH连接/</id>
    <published>2017-07-12T19:18:58.757Z</published>
    <updated>2017-07-13T02:10:04.573Z</updated>
    
    <content type="html"><![CDATA[<p>为了方便与服务器的连接，避免每次都需输入密码，可采用SSH连接方式代替Http连接，这里简要介绍如何进行连接</p>
<h3 id="1、登录到服务器（我这里用的是ubuntu"><a href="#1、登录到服务器（我这里用的是ubuntu" class="headerlink" title="1、登录到服务器（我这里用的是ubuntu)"></a>1、登录到服务器（我这里用的是ubuntu)</h3><p><code>ssh -l root 123.207.244.252#root为用户名</code></p>
<h3 id="2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）"><a href="#2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）" class="headerlink" title="2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）"></a>2、在服务器产生公钥和秘钥（其它主机上产生也行，不过为了其它终端能方便的获取到秘钥，推荐在服务器上产生）</h3><p><code>ssh-keygen -t rsa</code></p>
<h3 id="3、在-ssh文件夹内创建authorized-keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限"><a href="#3、在-ssh文件夹内创建authorized-keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限" class="headerlink" title="3、在.ssh文件夹内创建authorized_keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限"></a>3、在.ssh文件夹内创建authorized_keys文件，同时将刚刚产生的公钥复制到里面，并且修改文件权限</h3><p><code>less id_rsa.pub &gt; authorized_keys 
chmod 777 authorized_keys</code></p>
<h3 id="4、将秘钥从服务端下载下来保存到本地用户目录下的-ssh文件夹下"><a href="#4、将秘钥从服务端下载下来保存到本地用户目录下的-ssh文件夹下" class="headerlink" title="4、将秘钥从服务端下载下来保存到本地用户目录下的.ssh文件夹下"></a>4、将秘钥从服务端下载下来保存到本地用户目录下的.ssh文件夹下</h3><p><code>scp -r root@123.207.244.252:~/.ssh/id_rsa ~/.ssh/id_rsa</code></p>
<h3 id="5、之后访问服务器就不需要密码了"><a href="#5、之后访问服务器就不需要密码了" class="headerlink" title="5、之后访问服务器就不需要密码了"></a>5、之后访问服务器就不需要密码了</h3>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为了方便与服务器的连接，避免每次都需输入密码，可采用SSH连接方式代替Http连接，这里简要介绍如何进行连接&lt;/p&gt;
&lt;h3 id=&quot;1、登录到服务器（我这里用的是ubuntu&quot;&gt;&lt;a href=&quot;#1、登录到服务器（我这里用的是ubuntu&quot; class=&quot;headerl
    
    </summary>
    
    
  </entry>
  
</feed>
